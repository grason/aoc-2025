# Advent of Code 2025

![Advent of Code](https://img.shields.io/badge/Advent%20of%20Code-2025-de1d3b?style=for-the-badge&logo=adventofcode)
![Stars](https://img.shields.io/badge/stars%20⭐-XX%20/%20100-yellow?style=for-the-badge)

My solutions for **[Advent of Code 2025](https://adventofcode.com/2025)**.

## Overview

This repository contains my personal solutions to the 2025 edition of Advent of Code, written day-by-day as the puzzles are released. I use this event as an opportunity to have fun, experiment with new language features, and occasionally try something completely different from my day-to-day work.

## Language & Tools

I'm going to attempt to do a different language each day, for the flex.

| Day | Language            | Mini background                                                                                             |
|-----|---------------------|-------------------------------------------------------------------------------------------------------------|
| 1   | Python              | Born 1991, the world's favorite glue language — readable, huge ecosystem, and still the AoC default.         | 
| 2   | Rust                | 2015 (stable), Mozilla's fearless attempt to make systems programming safe without a garbage collector.      | 
| 3   | Go                  | 2009, Google's love letter to C with goroutines and lightning-fast builds.                                   | 
| 4   | Zig                 | 2016-, a modern alternative to C that wants to be simple, fast, and comptime everything.                     | 
| 5   | C++                 | 1985, the 40-year-old teenager that keeps adding features faster than anyone can learn them.                 | 
| 6   | Haskell             | 1990, the grand cathedral of pure functional programming and lazy evaluation.                                |
| 7   | Elixir              | 2011, built on the 1986 Erlang VM — immutable data, processes, and OTP for fault-tolerant joy.               |
| 8   | TypeScript          | 2012, JavaScript with static types; the reason half the web now has a build step.                            |
| 9   | Ruby                | 1995, Matz's quest to make programmers happy — everything is an object, and blocks are beautiful.            | 
| 10  | C#                  | 2000, Microsoft's Java-that-isn't-Java; now open-source with LINQ and async/await superpowers.               | 
| 11  | Kotlin              | 2011, JetBrains' modern JVM language that made null-pointer exceptions mostly extinct.                       |
| 12  | Swift               | 2014, Apple's successor to Objective-C — fast, safe, and surprisingly nice outside of Xcode.                 |
| 13  | F#                  | 2005, the functional-first language that quietly lives inside the .NET ecosystem.                            |
| 14  | OCaml               | 1996, the industrial-strength functional language that influenced Rust, Haskell, and half the fintech world. |   
| 15  | Nim                 | 2008-, compiles to C, feels like Python, and lets you write macros that scare even C++ developers.           |
| 16  | Julia               | 2012, built for scientists who got tired of slow Python and memory-hungry MATLAB.                            |
| 17  | Racket              | 1995 (as PLT Scheme), a Lisp descendant designed for making languages and teaching.                          |
| 18  | Lua                 | 1993, tiny Brazilian scripting language that powers games, Redis, and half the embedded world.               |
| 19  | Perl                | 1987, the original Swiss-army chainsaw of text processing — still alive and still unreadable.                |
| 20  | V                   | 2019, a ridiculously simple systems language that wants to replace C without the 50 years of baggage.       |
| 21  | Crystal             | 2014, Ruby's syntax with ahead-of-time compilation and real concurrency.                                     | 
| 22  | Janet               | 2017-, a tiny, embeddable Lisp that feels like Clojure had a minimalist baby.                                |
| 23  | BQN                 | 2020, a modern array language in the APL family — one-liners so dense they bend spacetime.                   |
| 24  | Forth               | 1970, stack-based, postfix, and the reason some people still program in reverse Polish notation.             |
| 25  | x86-64 Assembly     | 2000s extension of the 1978 x86 lineage — the metal under everything else. Pure pain, pure power.            |

Stars and war stories will be added as I survive each day.

## Repository structure
- Input files are stored as `Day_XX/input.txt` (personal inputs, not shared)
- Problems are usually in `problem.txt`
- Solutions are in 'Day_XX/solution.py' or similar.